# 3.4. * Написать функцию thesaurus_adv(), принимающую в качестве аргументов строки в формате «Имя Фамилия»
# и возвращающую словарь, в котором ключи — первые буквы фамилий, а значения — словари,
# реализованные по схеме предыдущего задания и содержащие записи, в которых фамилия начинается
# с соответствующей буквы. Например:
# >>> thesaurus_adv("Иван Сергеев", "Инна Серова", "Петр Алексеев", "Илья Иванов", "Анна Савельева")
#      {"А": {"П": ["Петр Алексеев"]},
#       "И": {"И": ["Илья Иванов"]},
#       "С": {"И": ["Иван Сергеев", "Инна Серова"], "А": ["Анна Савельева"]}}
# Как поступить, если потребуется сортировка по ключам?

names0 = ("Иван Сергеев", "Инна Серова", "Петр Алексеев", "Илья Иванов", "Анна Савельева")
names1 = ('михаиЛ булгаКов', 'оскар Уайльд', 'Лев толстой', 'анна ахМатова', 'Халед Хоссейни',
          'Владимир Бабкин', 'Максим Шахов', 'Алла Карпова', 'Роджер Желязны', 'Гузель Яхина')
names2 = ('Виктория Шваб', 'Карин Жибель', 'Анджей Ясинский', 'Николай Живцов', 'Ричард Байерс',
          'Антония Байетт', 'Алексей Хохлатов', 'Анвар Булгаков', 'Алесь Адамович', 'Фредрик Бакман')


def thesaurus_adv(names, names_dict=None):
    if (names_dict is None): names_dict = {}

    # Хотел создать список
    # list_xxx = ['A', ['a0', ['a00', 'a01'], 'b0', ['b00', 'b01']], 'B', ['a1', ['a10', 'a11'], 'b1', ['b10', 'b11']]]
    # и одной строкой типа
    # dic = {key1: {key2: val for key2 in key1 for val in key2} for key1 in list_xxx}
    # создать словарь из списка. Потратил много времени. Не получилось. Не хватило знаний.
    #
    # Сортировка списка необязательна. Для тренировки.
    list_names = sorted([x.title().split() for x in names], key=lambda x: (x[1], x[0]))

    for name, l_name in list_names:
        n_k, ln_k = name[:1], l_name[:1]    # вырезаем ключи, нач буквы имени и фамилии
        ful_name = f'{name} {l_name}'
        val = names_dict.get(ln_k)
        if val is None:                     # 1 ключ по фамилии не существует
            names_dict[ln_k] = {n_k: ful_name}
        elif val.get(n_k) is None:          # 2 ключ по имени не существует
            names_dict[ln_k][n_k] = ful_name
        else:
            names_dict[ln_k][n_k] += f' {ful_name}'
    return names_dict


my_dict0 = thesaurus_adv(names0)
my_dict1 = thesaurus_adv(names1)
my_dict2 = thesaurus_adv(names2)
result1 = {**my_dict0, **my_dict1, **my_dict2}
result2 = my_dict0 | my_dict1 | my_dict2

# И старая, и новая (|) операции обеЪединения словарей затирают предыдущие зночения,
# поэтому дописал функцию c возможностью передачи в нее старый словарь для объединения с новым.
print(result2)
my_dict_all = thesaurus_adv(names2, (thesaurus_adv(names1, thesaurus_adv(names0))))
print(my_dict_all)
